전달 함수는 유일한 인수로서 양을 취한다. 매개 변수인 withdraw_amount 값을 몇 줄 위에 선언한 withdraw 함수에 전달한다.
바로 다음 줄은 닫는 중괄호이며, withdraw 함수 정의의 끝을 나타낸다.

아래에 우리는 하나 더 함수를 선언한다:

  function () public payable {}

이 함수는 계약을 트리거 한 트랜잭션이 계약에서 선언된 함수나 또는 어떠한 함수도 전혀 지정하지 않았거나 데이터를 포함하지 않은 경우에 호출되는 소위 "대체"또는 기본 함수이다.
계약에는 하나의 기본 함수(이름 없음)를 가질 수 있으며 일반적으로 이더를 받는 계약이다.
이러한 이유로 기본 함수는 공개 및 지불 기능으로 정의되며. 이는 이더를 계약에 수용 할 수 있음을 의미한다.
중괄호 {}의 빈 정의에 표시된 것처럼 이더를 받는 것 외에는 아무 것도 하지 않는다.
이더를 지갑과 같은 계약 주소로 보내는 거래를 발생하면 이 함수가 처리한다.

우리의 기본 함수 바로 아래에는 파우셋 계약 정의를 닫는 마지막 닫는 중괄호가 있다.

=== 파우셋 계약서 작성
첫 번째 예제 계약을 만들었으므로 Solidity 컴파일러를 사용하여 Solidity 코드를 EVM 바이트 코드로 변환해야한다.  EVM은 바이트 코드를 블록 체인 자체에서 실행할 수 있다.

Solidity 컴파일러는 a) 독립 실행 파일, b) 다양한 프레임 워크의 일부, c) IDE (Integrated Development Environments)에 번들로 제공된다.
일을 간단하게하기 위해, 우리는 유명한 IDE 중 하나인 Remix를 사용할 것이다.

Chrome 브라우저 (앞서 설치 한 MetaMask 지갑 포함)를 사용하여 다음 위치에서 Remix IDE로 이동하시오.
https://remix.이더리움.org/

Remix를 처음 로드하면 ballot.sol이라는 견본 계약으로 시작된다.
필요하지 않으므로 그림 2-10과 같이 탭 모서리의 x를 클릭하여 닫는다.

그림 2-10. 기본 예제 탭 닫기

이제 왼쪽 툴바에서 더하기를 클릭하여 새 탭을 추가하고 그림 2-11과 같이 새 파일을 Faucet.sol의 이름으로 지정하시오.

그림 2-11. 더하기 기호를 클릭하여 새 탭을 연다.

새 탭이 열리면 그림 2-12와 같이 예제 Faucet.sol의 코드를 복사하여 붙여 넣는다.

그림 2-12. 파우셋 예제 코드를 새 탭에 복사하시오.

이제 Faucet.sol 계약을 Remix IDE에 로드하면 IDE가 자동으로 코드를 컴파일한다.
모두 잘되면 오른쪽에 컴파일 탭 아래에 "파우셋"이 표시된 녹색 상자가 나타나고 그림 2-13에서 볼 수 있듯이 컴파일이 성공적으로 완료되었는지 확인한다.

그림 2-13. Remix가 Faucet.sol 계약을 성공적으로 컴파일한다.

만약 문제가 발생한다면 가장 자주 발생하는 문제는 Remix IDE가 0.4.19와 다른 Solidity 컴파일러 버전을 사용하고 있다는 것이다.
이 경우, 우리의 pragma 지시어는 Faucet.sol의 컴파일을 막을 것이다.
컴파일러 버전을 변경하려면 "설정"탭으로 이동하여 컴파일러 버전을 0.4.19로 설정하고 다시 시도하시오.

Solidity 컴파일러는 이제 Faucet.sol을 EVM 바이트 코드로 컴파일 한다.
만약 바이트 코드에 관심이 있다면, 바이트 코드는 다음과 같다.

  PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1

EVM 바이트 코드에서 직접 프로그래밍하는 대신 Solinity와 같은 고수준 언어를 사용할 수 있어 기쁘지 않은가? 나도!

=== 블록 체인에 계약 생성하기

그래서 우리는 계약을 만든다. 이것을 바이트 코드로 컴파일한다.
이제, 우리는 이더리움 블록 체인에 계약을 "등록" 해야한다.
우리는 Ropsten testnet을 사용하여 계약을 테스트 할 것이고, 이것이 우리가 제출하고자 하는 블록 체인이다.

블록 체인에 계약을 등록하는 것은 목적지가 주소가 0x0000000000000000000000000000000000000000 (0 주소라고도 함)인 특수 트랜잭션을 만드는 것이다.
0 주소(zero address)는 계약을 등록하고자하는 이더리움 블록 체인에 알리는 특별한 주소이다.
다행히도 Remix IDE가 이 모든 것을 처리하고 메타마스크에 트랜잭션을 보낸다.

먼저 "Run"탭으로 전환하고 "Environment"드롭 다운 선택 상자에서 "Injected Web3"를 선택하시오.
이렇게하면 Remix IDE가 MetaMask 지갑에 연결되고 MetaMask를 통해 Ropsten Test Network에 연결됩니다.
일단 그렇게하면 Environment 아래에서 "Ropsten"을 볼 수 있습니다.
또한 계정 선택 상자에는 지갑의 주소가 표시됩니다 (그림 2-14 참조).

그림 2-14. Remix IDE "Run"탭, "Injected Web3"환경 선택됨

방금 확인한 "실행"설정 바로 아래에 파우셋 계약이 생성될 준비가 되어있다.
그림 2-15와 같은 "Deploy"버튼을 클릭하시오 :

그림 2-15. 실행 탭에서 Deploy 버튼을 클릭하시오.

Remix는 특별한 "생성"트랜잭션을 생성 할 것이고 MetaMask는 그림 2-16과 같이 당신에게 승인을 요청할 것이다.
계약 생성 트랜잭션에는 이더가 없지만 258 바이트 (컴파일 된 계약)이며 가스 10 Gwei를 소비한다.
승인하려면 'Submit'을 클릭하시오.

그림 2-16. 계약 생성 트랜잭션을 보여주는 MetaMask

이제 당신은 기다려야한다. Ropsten에서 계약 체결을 위해 약 15 ~ 30 초가 소요된다.
Remix는 많은 일을 하는 않는 것처럼 보이지만 인내심을 가져라.

계약서가 작성되면 Run 탭 하단에 나타난다.

그림 2-17. 파우셋 계약이 살아있다!

그림 2-17과 같이 파우셋 계약은 이제 자체 주소를 가지고 있다.
Remix에서는 0x72e ... .c7829의 파우셋으로 표시한다 (임의의 문자와 숫자로 이루어진 당신 주소는 다를 수 있다).
오른쪽의 작은 클립 보드 기호를 사용하면 계약 주소를 클립 보드로 복사 할 수 있다.
우리는 다음 섹션에서 그것을 사용할 것이다.

=== 계약 체결

지금까지 배운 내용을 요약해 보자. 이더리움 계약은 EVM이라고 하는 가상 시스템에서 실행되는 돈을 제어하는 프로그램이다.
계약은 블록 체인에 기록 될 바이트 코드를 제출하는 특별한 트랜잭션에 의해 생성된다.
계약이 블록체인에서 생성되면 지갑과 마찬가지로 이더리움 주소를 갖게된다.
누군가 계약 주소로 거래를 보낼 때마다 거래를 입력값으로 계약이 EVM에서 실행된다.
계약 주소로 보내지는 거래에는 이더, 데이터 또는 둘 다를 포함 할 수 있다.
거래가 이더를 포함하면, 이는 계약 잔액에 "예치된다".
데이터가 포함되어 있으면 데이터에서 계약의 명명된 함수를 지정하고 호출하여 함수에 인수를 전달할 수 있다.

=== 블록 탐색기에서 계약 주소 보기

이제, 우리는 블록 체인에 기록 된 계약을 가지고 있으며 그 계약이 이더리움 주소를 가지고 있음을 볼 수 있다.
ropsten.etherscan.io 블록 탐색기에서 이더리움 주소로 확인하고 계약 내용을 확인하시오.
이름 옆에있는 클립 보드 아이콘을 클릭하여 계약 주소를 복사하시오 (그림 2-18 참조).

그림 2-18. Remix에서 계약 주소 복사

Remix를 다시 사용하므로 열어 두시오. 이제 브라우저를 ropsten.etherscan.io로 이동하고 그림 2-19와 같이 검색 상자에 주소를 붙여 넣으시오.
계약의 이더리움 주소 기록을 볼 수 있다:

그림 2-19. 이더리움 스캔 블록 탐색기에서 파우셋 계약 주소보기

=== 계약 자금 조달

현재 계약은 계약 생성 거래 하나만 기록되어 있다.
보다시피 계약에는 이더(제로 잔액)도 없다.
왜냐하면 우리가 가질 수는 있겠지만 생성 거래에서 계약에 어떤 이더도 보내지 않았기 때문이다.
파우셋에는 자금이 필요하다! 첫 번째 프로젝트는 MetaMask를 사용하여 이더를 계약으로 보내는 것이다.
클립 보드에 계약의 주소가 남아 있어야 한다(그렇지 않은 경우 Remix에서 다시 복사하시오).
다른 이더리움 주소와 마찬가지로 MetaMask를 열고 1 이더를 보내시오(그림 2-20 참조).

그림 2-20. 계약 주소로 1 이더 보내기

1분 안에 etherscan 블록 탐색기를 다시 로드하면 계약 주소에 대한 또 다른 트랜잭션과 업데이트 된 1이더의 잔액이 표시된다.

Faucet.sol 코드에서 이름없는 기본 공개 payable 함수를 기억하는가?
그것은 다음과 같다:

  function () public payable {}

계약 주소로 트랜잭션을 전송할 때 호출 할 함수를 지정하는 데이터가 없으면 이 기본 함수를 호출한다.
우리는 이 함수를 payable로 선언했기 때문에 1 이더를 계약 계좌 잔액에 입금한다.
거래로 인해 EVM에서 계약이 실행되어 잔액이 업데이트되었다.
우리는 파우셋에 자금을 조달했다!




CHAPTER 3
이더리움 클라이언트

이더리움 클라이언트는 이더리움 사양을 구현하고 다른 이더리움 클라이언트와 피어-투-피어 네트워크를 통해 통신하는 소프트웨어 응용 프로그램이다.
다른 이더리움 클라이언트간에는 참조 사양 및 표준화 된 통신 프로토콜을 준수하면 상호 운용된다.
이러한 서로 다른 클라이언트가 다른 팀과 다른 프로그래밍 언어로 구현되는 동안 이들은 모두 동일한 프로토콜으로 "소통하고" 동일한 규칙을 따른다.
따라서 이들은 모두 동일한 이더리움 네트워크에서 운영 및 상호 작용하는 데 사용될 수 있다.

이더리움은 오픈 소스 프로젝트이며 모든 주요 고객의 소스 코드는 오픈 소스 라이선스 (예 : LGPL v3.0)에서 사용할 수 있으므로 무료로 다운로드하여 다른 용도로 사용할 수 있다.
오픈 소스란 단순히 자유롭게 사용할 수있는 것 이상을 의미한다.
또한 이더리움은 공개 자원 봉사자 커뮤니티에 의해 개발되었으며 누구든지 수정할 수 있음을 의미한다.
지켜보는 눈이 많을수록 신뢰할 수있는 코드가된다.

이더리움은 "옐로 페이퍼"라는 공식 사양에 의해 정의된다 (7 페이지의 "추가 참조"참조).

예를 들어 비트코인은 공식적인 방식으로 정의되지 않았다.
비트코인의 "사양"이 비트코인 코어(Core) 참조 구현인 반면 이더리움은 영어와 수학(공식) 사양이 결합되어 문서화되어 있다.
이 공식 사양은 다양한 이더리움 개선 제안과 함께 이더리움 클라이언트의 표준 동작을 정의한다.
옐로 페이퍼는 이더리움에 주요 변경 사항이 적용됨에 따라 주기적으로 업데이트된다.

이더리움의 명확한 공식 사양의 결과로, 이더리움 클라이언트가 독립적으로 개발되었지만 상호 운용 가능한 소프트웨어 구현이 많이 있다.
이더리움은 다른 블록 체인보다 네트워크에서 실행되는 구현의 다양성이 더 크며 이는 일반적으로 좋은 점으로 평가된다.
사실, 예를 들어, 네트워크에 대한 공격으로부터 방어하기위한 훌륭한 방법으로 입증되었다.
왜냐하면 특정 클라이언트의 구현 전략을 악용하는 것은 개발자가 공격을 패치하는 동안 개발자를 괴롭히지만 다른 클라이언트는 네트워크 거의 영향을 주지 않기 때문이다.


이더리움 네트워크

이더리움 "옐로 페이퍼"에 정의 된 공식 사양에 크게 부합하지만 서로 상호 작용할 수도 있고 그렇지 않을 수도 있는 다양한 이더리움 기반 네트워크가 존재합니다.

이더리움 기반 네트워크는 이더리움, 이더리움 클래식(Classic), 엘라(Ella), 익스팬스(Expanse), 유비크(Ubiq), 뮤지코인(Musicoin) 및 기타 여러 네트워크가 있습니다.
대부분 프로토콜 수준에서 호환되는 반면,이 네트워크는 이더리움 클라이언트 소프트웨어의 관리자가 각 네트워크를 지원하기 위해 작은 변경을 요구하는 기능 또는 속성을 가지고있는 경우가 많다.
이 때문에 이더리움 클라이언트 소프트웨어의 모든 버전이 모든 이더리움 기반 블록 체인을 실행하는 것은 아니다.

현재 6 가지 언어로 작성된 이더리움 프로토콜의 6 가지 기본 구현이 있다.

• 러스트(Rust)로 작성된 패리티(Parity)
• 고(Go)로 작성된 게스(Geth)
• C++로 작성된 cpp-이더리움
• 파이선(Python)으로 작성된 파이이더리움(pyethereum)
• 스칼라(Scala)로 작성된 맨티스(Mantis)
• 자바(Java)로 작성된 하모니(Harmony)

이번 섹션에서는 패리티(Parity)와 게스(Geth)라는 가장 일반적인 두 클라이언트를 살펴 보겠다.
각 클라이언트를 사용하여 노드를 설정하고 명령-줄(command-line) 및 응용 프로그래밍 인터페이스(API) 중 일부를 탐색하는 방법을 학습한다.


전체 노드를 실행해야하는가?

블록 체인의 건강(health), 탄력성(resilience) 및 검열 저항(censorship resistance)은 독립적으로 운영되고 지리적으로 분산되어있는 노드가 많다는 데 달려 있다.
각 전체 노드는 다른 새 노드가 블록 데이터를 얻어 작업을 부트스트랩(bootstrap)하고 운영자에게 모든 거래 및 계약에 대해 신뢰할 수 있고 독립적인 검증을 제공 할 수 있도록 도와준다.

그러나 전체 노드를 실행하면 하드웨어 리소스 및 대역폭 비용이 발생한다.
전체 노드는 80GB 이상의 데이터를 다운로드해야하며 (클라이언트에 따라 2018년 4월 기준) 로컬 하드 드라이브에 저장해야한다.
새로운 트랜잭션 및 블록이 추가되면서 매일 이러한 데이터 부담이 상당히 빠르게 증가한다.
이 주제는 55 페이지의 "전체 노드의 하드웨어 요구 사항"에서 보다 자세히 설명한다.

이더리움 개발에는 라이브 메인넷(mainnet) 네트워크에서 실행중인 전체 노드가 필요하지 않다.
테스트넷(testnet) 노드(작은 공용 테스트 블록 체인 중 하나에 연결), Ganache와 같은 로컬 프라이빗 블록 체인 또는 Infura와 같은 서비스 공급자가 제공하는 클라우드 기반 이더리움 클라이언트로 원하는 대부분의 작업을 수행 할 수 있다.

블록 체인의 로컬 복사본을 저장하지 않거나 블록 및 트랜잭션의 유효성을 확인하지 않는 원격 클라이언트를 실행할 수도 있다.
이 클라이언트는 지갑의 기능을 제공하며 거래를 생성하고 전파 할 수 있다.
원격 클라이언트를 사용하여 자신의 전체 노드, 공용 블록 체인, 공용 또는 허가된 (권위 증명:Proof-of-Authority) 테스트넷 또는 개인 로컬 블록 체인과 같은 기존 네트워크에 연결할 수 있다.
실제로 모든 다른 노드 옵션간에 전환하는 편리한 방법으로 메타마스크(MetaMask), 에메랄드 지갑(Emerald Wallet), MyEtherWallet 또는 MyCrypto와 같은 원격 클라이언트를 사용할 것이다.

"원격 클라이언트"및 "지갑"이라는 용어는 동일한 의미로 사용이 되긴 하지만 서로 다른 점이 있다. 일반적으로 원격 클라이언트는 지갑의 거래 기능 외에도 API(예 : web3.js API)를 제공한다.

이더리움의 원격 지갑 개념을 라이트 클라이언트(Light Client:비트코인의 Simplified Payment Verification 클라이언트와 유사함)의 개념과 혼동하지 마시오.
라이트 클라이언트는 블록 헤더의 유효성을 검사하고 머클(Merkle) 증명을 사용하여 블록 체인에서의 트랜잭션 포함 여부를 확인하고 그 영향도를 결정하여 전체 노드에 대해 비슷한 수준의 보안을 제공한다.
반대로 이더리움 원격 클라이언트는 블록 헤더 또는 트랜잭션의 유효성을 검사하지 않습니다.
그들은 전체 클라이언트를 신뢰하여 블록 체인에 대한 액세스 권한을 부여하므로 중요한 보안 및 익명성 보장이 없다.
너 스스로 실행하는 전체 클라이언트(full client)를 사용하여 이러한 문제를 완화 할 수 있다.


전체 노드의 장점과 단점

전체 노드를 실행하기로 선택하면 네트워크를 연결하는 데 도움이되지만 경미한 수준의 비용이 발생한다.
몇 가지 장점과 단점을 살펴 보자.

장점 :

• 이더리움 기반 네트워크의 탄력성과 검열 저항을 지원.
• 모든 거래를 신뢰할 수 있는 것으로 검증.
• 중개자 없이 퍼블릭 블록 체인의 모든 계약과 상호 작용 가능.
• 중개자 없이 계약을 퍼블릭 블록 체인에 직접 디플로이 가능.
